---
sidebar_position: 2
---

# Vue 的引用

这里我们列举两种常用的方法

# 创建标签式引用

完整代码及分析如下

```js
// ==UserScript==
// @name         测试Vue引用
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       LHD
// @match        https://bbs.tampermonkey.net.cn/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=tampermonkey.net.cn
// @grant        none
// @run-at       document-start
// ==/UserScript==

//初始化一个有地址的 sciprt 标签，并且注入到页面中
//注意这里我们使用了 run-at 让其在页面开始尽早注入脚本。
let script = document.createElement("script");
script.setAttribute("type", "text/javascript");
script.src = "https://cdn.jsdelivr.net/npm/vue@next";
document.documentElement.appendChild(script);

//添加一个window.onload回调
window.onload = () => {
  //text是其我们想插入的文本
  //注意：id="app"是为了让我们可以方便的找到元素
  //{{ message }}是属于vue的语法糖
  //只要在{{}}输入其变量或表达式名字，就会在运行时填入变量并返回其结果
  let text = `<div id="app" style="position: absolute;top: 50vh;left: 50vw;background:#fb7d7d;width: 100px;height: 100px;">
           {{ message }}
    </div>`;
  var el = document.createElement("div");
  el.innerHTML = text;
  //放置到body的末尾
  document.body.append(el);
  const App = {
    //vue固定写法
    //我们在这个对象内填入数据，Vue将会从这个对象里寻找数据。

    //这里之所以需要函数返回，是因为放了一个页面同时启用多个组件，导致其数据发生共
    //一个组件修改数据，N个相同的组件同样修改数据，因为对象是引用的，所以会发生这种情况。

    //而使用函数进行返回对象，相当于函数做了一个生成器，每次返回的对象都是再次生成的
    //这样每个组件都有一个属于自己的独立数据，不用担心出现数据污染问题。
    data() {
      return {
        message: "Hello World",
      };
    },
  };
  //对createApp传入了App对象，然后会返回给我们一个对象，我们调用这个对象的mount进行挂载，这部分属于固定写法
  const app = Vue.createApp(App);
  app.mount("#app");
};
```

